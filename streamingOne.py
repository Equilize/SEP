# This program assumes the files generated by 2023_pickler.py under the same
# constants specified in _2023_constants.py has already been run.
#
# It outputs to standard out a proceduarlly generated non-repeating block model
# suitable for compression and can run at the front end of a stream processing
# pipeline to generate unique valid input data ad infinitum.
import os
import pickle
import textwrap
import random
import argparse
import numpy as np
import msvcrt
import matplotlib.pyplot as plt
import matplotlib.animation as animation

from _2023_constants import *

parser = argparse.ArgumentParser(
    formatter_class=argparse.RawDescriptionHelpFormatter,
    epilog=
        "Streams an infinite non-repeating block model to standard output.\n"
)
parser.add_argument(
    "-s", 
    "--seed",
    default=0,
    help="arbitrary integer value allowing output to be reproduced")

args = parser.parse_args()

# Configure for reproducible output if a seed is provided, otherwise leave it random
if args.seed != 0: random.seed(args.seed)

# Set up py = f(px) in the shape of a cosine between 0 and 1 with the zero 1/P from the left
PI2 = 2*np.pi
n = np.arange(0, N)
px = np.linspace(0, PI2, num=N, endpoint=False)
py = 0.5 - np.cos(px-PI2/P)/2

# Initialise noise buffers from pickle files
noise_buffers = np.empty((P,N,Y,X))
for p in range(P):
    file_name = cache_file_name(phase=p)
    if os.path.isfile(file_name):
        with open(file_name, "rb") as file:
            noise_buffers[p] = pickle.load(file)
    else:
        print("ERROR: file {} not found. You need to run 2023_pickler.py first.".format(file_name))
        exit(1)

# Output model header with an large enough depth count to break mem allocators
print("{},{},{},32,32,16".format(X, Y, 2147483647))
for s in DOMAIN_CHARS:
    print("{}, {}".format(s.decode("ascii"), s.decode("ascii")))
print("")

# Initialise domain list from _2023_constants.py
active_domain_vals = np.array(random.choices(DOMAIN_VALS, k=P), dtype=np.uint8)

# Initialise field buffers with cosine decays and correct phase rotations
field_buffers = noise_buffers * py[:,np.newaxis,np.newaxis]
for p in range(P):
    field_buffers[p,...] = np.roll(field_buffers[p], p*W, axis=0)

# Generate blocks, one W-sized chunk at a time, forever.
argmax_buffer = np.empty((W,Y,X), dtype=np.uint8)
while(True):
    for p, w in zip(range(P), range(0,N,W)):
        np.argmax(field_buffers[:,w:w+W,:,:], 0, out=argmax_buffer)
        output_vals = active_domain_vals[argmax_buffer]
        output_string = DOMAIN_CHARS[output_vals].tobytes().decode("ascii")
        for s in range(W):
            print(textwrap.fill(output_string[s*Y*X:(s+1)*Y*X], width=X))
            print("")
            # Uncomment below for key-press pause on each slice
            #c = msvcrt.getch()
            #if c == b'q': exit(0)
        # Phase p is now complete and can be changed out with no loss of
        # continuity because its contribution is zero at this point in the
        # cycle. This is the key to a smooth everchanging model. The choice
        # every W slices is from P*Y possibilities and the number of possible
        # concurrent phase overlaps is N^4.
        #
        # Randomly roll slot p in noise_buffers.
        noise_buffers[p] = np.roll(noise_buffers[p], random.randrange(N), axis=1)
        # Use it to re-initialise slot p in field_buffers
        field_buffers[p] = noise_buffers[p] * py[:,np.newaxis,np.newaxis]
        # Then phase shift it into the correct place
        field_buffers[p] = np.roll(field_buffers[p], p*W, axis=0)
        # Then randomly pick a new domain to occupy slot p
        active_domain_vals[p] = random.choice(DOMAIN_VALS)
